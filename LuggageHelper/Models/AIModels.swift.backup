import Foundation
import UIKit
import CoreImage

// MARK: - AI åŠŸèƒ½ç›¸å…³æ•°æ®æ¨¡å‹

/// ç‰©å“ä¿¡æ¯è¯†åˆ«ç»“æœ
struct ItemInfo: Codable, Identifiable, Equatable, Hashable {
    let id = UUID()
    let name: String
    let category: ItemCategory
    let weight: Double // å…‹
    let volume: Double // ç«‹æ–¹å˜ç±³
    let dimensions: Dimensions?
    let confidence: Double // è¯†åˆ«ç½®ä¿¡åº¦ 0.0-1.0
    let alternatives: [ItemInfo] // æ›¿ä»£å“å»ºè®®
    let source: String // æ•°æ®æ¥æº
    
    enum CodingKeys: String, CodingKey {
        case name, category, weight, volume, dimensions, confidence, alternatives, source
    }
    
    /// åˆå§‹åŒ–æ–¹æ³•
    init(name: String, category: ItemCategory, weight: Double, volume: Double, 
         dimensions: Dimensions? = nil, confidence: Double = 1.0, 
         alternatives: [ItemInfo] = [], source: String = "AIè¯†åˆ«") {
        self.name = name
        self.category = category
        self.weight = weight
        self.volume = volume
        self.dimensions = dimensions
        self.confidence = confidence
        self.alternatives = alternatives
        self.source = source
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

/// ç‰©å“ç±»åˆ«æšä¸¾
enum ItemCategory: String, Codable, CaseIterable {
    case clothing = "clothing"           // è¡£ç‰©
    case electronics = "electronics"     // ç”µå­äº§å“
    case toiletries = "toiletries"      // æ´—æ¼±ç”¨å“
    case documents = "documents"         // è¯ä»¶æ–‡ä»¶
    case medicine = "medicine"           // è¯å“ä¿å¥
    case accessories = "accessories"     // é…é¥°ç”¨å“
    case shoes = "shoes"                // é‹ç±»
    case books = "books"                // ä¹¦ç±æ–‡å…·
    case food = "food"                  // é£Ÿå“é¥®æ–™
    case sports = "sports"              // è¿åŠ¨ç”¨å“
    case beauty = "beauty"              // ç¾å®¹åŒ–å¦†
    case other = "other"                // å…¶ä»–
    
    /// æ˜¾ç¤ºåç§°
    var displayName: String {
        switch self {
        case .clothing: return "è¡£ç‰©"
        case .electronics: return "ç”µå­äº§å“"
        case .toiletries: return "æ´—æ¼±ç”¨å“"
        case .documents: return "è¯ä»¶æ–‡ä»¶"
        case .medicine: return "è¯å“ä¿å¥"
        case .accessories: return "é…é¥°ç”¨å“"
        case .shoes: return "é‹ç±»"
        case .books: return "ä¹¦ç±æ–‡å…·"
        case .food: return "é£Ÿå“é¥®æ–™"
        case .sports: return "è¿åŠ¨ç”¨å“"
        case .beauty: return "ç¾å®¹åŒ–å¦†"
        case .other: return "å…¶ä»–"
        }
    }
    
    /// å›¾æ ‡
    var icon: String {
        switch self {
        case .clothing: return "ğŸ‘•"
        case .electronics: return "ğŸ“±"
        case .toiletries: return "ğŸ§´"
        case .documents: return "ğŸ“„"
        case .medicine: return "ğŸ’Š"
        case .accessories: return "ğŸ‘œ"
        case .shoes: return "ğŸ‘Ÿ"
        case .books: return "ğŸ“š"
        case .food: return "ğŸ"
        case .sports: return "âš½"
        case .beauty: return "ğŸ’„"
        case .other: return "ğŸ“¦"
        }
    }
}

/// ç‰©å“å°ºå¯¸
struct Dimensions: Codable, Equatable {
    let length: Double // é•¿åº¦ (cm)
    let width: Double  // å®½åº¦ (cm)
    let height: Double // é«˜åº¦ (cm)
    
    /// è®¡ç®—ä½“ç§¯
    var volume: Double {
        return length * width * height
    }
    
    /// æ ¼å¼åŒ–æ˜¾ç¤º
    var formatted: String {
        return String(format: "%.1fÃ—%.1fÃ—%.1f cm", length, width, height)
    }
}

// MARK: - ç…§ç‰‡è¯†åˆ«ç›¸å…³æ¨¡å‹

/// ç…§ç‰‡è¯†åˆ«ç­–ç•¥
enum PhotoRecognitionStrategy: String, Codable, CaseIterable {
    case aiVision = "aiVision"           // AI è§†è§‰è¯†åˆ«
    case textExtraction = "textExtraction" // æ–‡å­—æå–è¯†åˆ«
    case colorAnalysis = "colorAnalysis"   // é¢œè‰²åˆ†æ
    case shapeAnalysis = "shapeAnalysis"   // å½¢çŠ¶åˆ†æ
    
    var displayName: String {
        switch self {
        case .aiVision: return "AI è§†è§‰è¯†åˆ«"
        case .textExtraction: return "æ–‡å­—è¯†åˆ«"
        case .colorAnalysis: return "é¢œè‰²åˆ†æ"
        case .shapeAnalysis: return "å½¢çŠ¶åˆ†æ"
        }
    }
}

/// è¯†åˆ«æ–¹æ³•
enum RecognitionMethod: String, Codable {
    case cloudAPI = "cloud_api"
    case offlineML = "offline_ml"
    case hybrid = "hybrid"
    case cached = "cached"
    case userCorrected = "user_corrected"
}

/// ç…§ç‰‡è¯†åˆ«ç»“æœ
struct PhotoRecognitionResult: Codable, Identifiable {
    let id: UUID
    let itemInfo: ItemInfo
    let confidence: Double
    let recognitionMethod: RecognitionMethod
    let processingTime: TimeInterval
    let imageMetadata: ImageMetadata
    let alternatives: [RecognitionCandidate]
    let qualityScore: Double
    let timestamp: Date
    
    // ç”¨æˆ·åé¦ˆ
    var userFeedback: UserFeedback?
    var isVerified: Bool
    var correctedInfo: ItemInfo?
    
    enum CodingKeys: String, CodingKey {
        case id, itemInfo, confidence, recognitionMethod, processingTime, imageMetadata
        case alternatives, qualityScore, timestamp, userFeedback, isVerified, correctedInfo
    }
    
    init(itemInfo: ItemInfo, confidence: Double, recognitionMethod: RecognitionMethod, 
         processingTime: TimeInterval, imageMetadata: ImageMetadata, 
         alternatives: [RecognitionCandidate] = [], qualityScore: Double = 1.0) {
        self.id = UUID()
        self.itemInfo = itemInfo
        self.confidence = confidence
        self.recognitionMethod = recognitionMethod
        self.processingTime = processingTime
        self.imageMetadata = imageMetadata
        self.alternatives = alternatives
        self.qualityScore = qualityScore
        self.timestamp = Date()
        self.isVerified = false
    }
}

/// è¯†åˆ«å€™é€‰é¡¹
struct RecognitionCandidate: Codable, Identifiable {
    let id: UUID
    let itemInfo: ItemInfo
    let confidence: Double
    let source: String
    
    enum CodingKeys: String, CodingKey {
        case id, itemInfo, confidence, source
    }
    
    init(itemInfo: ItemInfo, confidence: Double, source: String) {
        self.id = UUID()
        self.itemInfo = itemInfo
        self.confidence = confidence
        self.source = source
    }
}

/// å›¾ç‰‡å…ƒæ•°æ®
struct ImageMetadata: Codable {
    let width: Int
    let height: Int
    let fileSize: Int
    let format: String
    let dominantColors: [String]
    let brightness: Double
    let contrast: Double
    let hasText: Bool
    let estimatedObjects: Int
    let size: CGSize
    let timestamp: Date
    
    enum CodingKeys: String, CodingKey {
        case width, height, fileSize, format, dominantColors, brightness, contrast, hasText, estimatedObjects
        case size, timestamp
    }
    
    init(width: Int, height: Int, fileSize: Int, format: String, dominantColors: [String], 
         brightness: Double, contrast: Double, hasText: Bool, estimatedObjects: Int) {
        self.width = width
        self.height = height
        self.fileSize = fileSize
        self.format = format
        self.dominantColors = dominantColors
        self.brightness = brightness
        self.contrast = contrast
        self.hasText = hasText
        self.estimatedObjects = estimatedObjects
        self.size = CGSize(width: width, height: height)
        self.timestamp = Date()
    }
}

/// ç”¨æˆ·åé¦ˆ
struct UserFeedback: Codable, Identifiable {
    let id: UUID
    let recognitionResultId: UUID
    let isCorrect: Bool
    let correctedName: String?
    let correctedCategory: ItemCategory?
    let correctedProperties: [String: String]?
    let rating: Int // 1-5
    let comments: String?
    let timestamp: Date
    
    enum CodingKeys: String, CodingKey {
        case id, recognitionResultId, isCorrect, correctedName, correctedCategory
        case correctedProperties, rating, comments, timestamp
    }
    
    init(recognitionResultId: UUID, isCorrect: Bool, correctedName: String? = nil, 
         correctedCategory: ItemCategory? = nil, correctedProperties: [String: String]? = nil,
         rating: Int = 3, comments: String? = nil) {
        self.id = UUID()
        self.recognitionResultId = recognitionResultId
        self.isCorrect = isCorrect
        self.correctedName = correctedName
        self.correctedCategory = correctedCategory
        self.correctedProperties = correctedProperties
        self.rating = rating
        self.comments = comments
        self.timestamp = Date()
    }
}

// MARK: - è£…ç®±ç›¸å…³æ¨¡å‹

/// è£…ç®±è®¡åˆ’
struct PackingPlan: Codable, Identifiable {
    let id = UUID()
    let luggageId: UUID
    let items: [PackingItem]
    let totalWeight: Double
    let totalVolume: Double
    let efficiency: Double // ç©ºé—´åˆ©ç”¨ç‡ 0.0-1.0
    let warnings: [PackingWarning]
    let suggestions: [String] // è£…ç®±å»ºè®®
    
    enum CodingKeys: String, CodingKey {
        case luggageId, items, totalWeight, totalVolume, efficiency, warnings, suggestions
    }
}

/// è£…ç®±ç‰©å“
struct PackingItem: Codable, Identifiable {
    let id = UUID()
    let itemId: UUID
    let position: PackingPosition
    let priority: Int // è£…ç®±ä¼˜å…ˆçº§ 1-10
    let reason: String // è£…ç®±å»ºè®®åŸå› 
    
    enum CodingKeys: String, CodingKey {
        case itemId, position, priority, reason
    }
}

/// è£…ç®±ä½ç½®
enum PackingPosition: String, Codable {
    case bottom = "bottom"       // åº•éƒ¨
    case middle = "middle"       // ä¸­éƒ¨
    case top = "top"            // é¡¶éƒ¨
    case side = "side"          // ä¾§é¢
    case corner = "corner"      // è§’è½
    
    var displayName: String {
        switch self {
        case .bottom: return "åº•éƒ¨"
        case .middle: return "ä¸­éƒ¨"
        case .top: return "é¡¶éƒ¨"
        case .side: return "ä¾§é¢"
        case .corner: return "è§’è½"
        }
    }
}

/// è£…ç®±è­¦å‘Š
struct PackingWarning: Codable, Identifiable {
    let id = UUID()
    let type: WarningType
    let message: String
    let severity: WarningSeverity
    
    enum CodingKeys: String, CodingKey {
        case type, message, severity
    }
}

/// è­¦å‘Šç±»å‹
enum WarningType: String, Codable {
    case overweight = "overweight"       // è¶…é‡
    case oversized = "oversized"         // è¶…å°ºå¯¸
    case fragile = "fragile"            // æ˜“ç¢å“
    case liquid = "liquid"              // æ¶²ä½“é™åˆ¶
    case battery = "battery"            // ç”µæ± é™åˆ¶
    case prohibited = "prohibited"       // ç¦æ­¢æºå¸¦
    case attention = "attention"         // æ³¨æ„äº‹é¡¹
}

/// è­¦å‘Šä¸¥é‡ç¨‹åº¦
enum WarningSeverity: String, Codable {
    case low = "low"        // ä½
    case medium = "medium"  // ä¸­
    case high = "high"      // é«˜
    case critical = "critical" // ä¸¥é‡
    
    var color: String {
        switch self {
        case .low: return "yellow"
        case .medium: return "orange"
        case .high: return "red"
        case .critical: return "purple"
        }
    }
}

/// è£…ç®±åˆ†æç»“æœ
struct PackingAnalysis: Codable, Identifiable {
    let id: UUID
    let luggageId: UUID
    let totalItems: Int
    let totalWeight: Double
    let totalVolume: Double
    let utilizationRate: Double // åˆ©ç”¨ç‡
    let categoryBreakdown: [PackingCategoryAnalysis]
    let recommendations: [SmartSuggestion]
    let warnings: [PackingWarning]
    let score: Double // è£…ç®±è¯„åˆ† 0-100
    let createdAt: Date
    
    enum CodingKeys: String, CodingKey {
        case id, luggageId, totalItems, totalWeight, totalVolume, utilizationRate
        case categoryBreakdown, recommendations, warnings, score, createdAt
    }
    
    init(luggageId: UUID, totalItems: Int, totalWeight: Double, totalVolume: Double, 
         utilizationRate: Double, categoryBreakdown: [PackingCategoryAnalysis], 
         recommendations: [SmartSuggestion], warnings: [PackingWarning], score: Double) {
        self.id = UUID()
        self.luggageId = luggageId
        self.totalItems = totalItems
        self.totalWeight = totalWeight
        self.totalVolume = totalVolume
        self.utilizationRate = utilizationRate
        self.categoryBreakdown = categoryBreakdown
        self.recommendations = recommendations
        self.warnings = warnings
        self.score = score
        self.createdAt = Date()
    }
}

/// è£…ç®±ç±»åˆ«åˆ†æ
struct PackingCategoryAnalysis: Codable {
    let category: ItemCategory
    let itemCount: Int
    let totalWeight: Double
    let totalVolume: Double
    let weightPercentage: Double
    let volumePercentage: Double
    let averageItemWeight: Double
    let averageItemVolume: Double
}

// MARK: - æ—…è¡Œå»ºè®®ç›¸å…³æ¨¡å‹

/// æ—…è¡Œå»ºè®®
struct TravelSuggestion: Codable, Identifiable {
    let id = UUID()
    let destination: String
    let duration: Int
    let season: String
    let activities: [String]
    let suggestedItems: [SuggestedItem]
    let categories: [ItemCategory]
    let tips: [String] // æ—…è¡Œå°è´´å£«
    let warnings: [String] // æ³¨æ„äº‹é¡¹
    
    enum CodingKeys: String, CodingKey {
        case destination, duration, season, activities, suggestedItems, categories, tips, warnings
    }
    
    /// è·å–å¿…éœ€å“æ•°é‡
    var essentialItemsCount: Int {
        return suggestedItems.filter { $0.importance == .essential }.count
    }
    
    /// è·å–æ€»é¢„ä¼°é‡é‡
    var totalEstimatedWeight: Double {
        return suggestedItems.compactMap { $0.estimatedWeight }.reduce(0, +)
    }
    
    /// è·å–æ€»é¢„ä¼°ä½“ç§¯
    var totalEstimatedVolume: Double {
        return suggestedItems.compactMap { $0.estimatedVolume }.reduce(0, +)
    }
}

/// å»ºè®®ç‰©å“
struct SuggestedItem: Codable, Identifiable {
    let id = UUID()
    let name: String
    let category: ItemCategory
    let importance: ImportanceLevel
    let reason: String
    let quantity: Int
    let estimatedWeight: Double? // é¢„ä¼°é‡é‡
    let estimatedVolume: Double? // é¢„ä¼°ä½“ç§¯
    
    enum CodingKeys: String, CodingKey {
        case name, category, importance, reason, quantity, estimatedWeight, estimatedVolume
    }
}

/// é‡è¦ç¨‹åº¦
enum ImportanceLevel: String, Codable, CaseIterable {
    case essential = "essential"     // å¿…éœ€å“
    case important = "important"     // é‡è¦
    case recommended = "recommended" // æ¨è
    case optional = "optional"       // å¯é€‰
    
    var displayName: String {
        switch self {
        case .essential: return "å¿…éœ€å“"
        case .important: return "é‡è¦"
        case .recommended: return "æ¨è"
        case .optional: return "å¯é€‰"
        }
    }
    
    var priority: Int {
        switch self {
        case .essential: return 4
        case .important: return 3
        case .recommended: return 2
        case .optional: return 1
        }
    }
}

// MARK: - èˆªç©ºå…¬å¸æ”¿ç­–ç›¸å…³æ¨¡å‹

/// èˆªç©ºå…¬å¸è¡Œææ”¿ç­–
struct AirlineLuggagePolicy: Codable, Identifiable {
    let id = UUID()
    let airline: String
    let carryOnWeight: Double // æ‰‹æè¡Œæé‡é‡é™åˆ¶ (kg)
    let carryOnDimensions: Dimensions // æ‰‹æè¡Œæå°ºå¯¸é™åˆ¶
    let checkedWeight: Double // æ‰˜è¿è¡Œæé‡é‡é™åˆ¶ (kg)
    let checkedDimensions: Dimensions // æ‰˜è¿è¡Œæå°ºå¯¸é™åˆ¶
    let restrictions: [String] // é™åˆ¶æ¡ä»¶
    let lastUpdated: Date // æœ€åæ›´æ–°æ—¶é—´
    let source: String // æ•°æ®æ¥æº
    
    enum CodingKeys: String, CodingKey {
        case airline, carryOnWeight, carryOnDimensions, checkedWeight, checkedDimensions
        case restrictions, lastUpdated, source
    }
    
    /// æ£€æŸ¥æ˜¯å¦ç¬¦åˆæ‰‹æè¡Œæè¦æ±‚
    func isCarryOnCompliant(weight: Double, dimensions: Dimensions) -> Bool {
        return weight <= carryOnWeight && 
               dimensions.length <= carryOnDimensions.length &&
               dimensions.width <= carryOnDimensions.width &&
               dimensions.height <= carryOnDimensions.height
    }
    
    /// æ£€æŸ¥æ˜¯å¦ç¬¦åˆæ‰˜è¿è¡Œæè¦æ±‚
    func isCheckedCompliant(weight: Double, dimensions: Dimensions) -> Bool {
        let totalDimension = dimensions.length + dimensions.width + dimensions.height
        let maxTotalDimension = checkedDimensions.length
        return weight <= checkedWeight && totalDimension <= maxTotalDimension
    }
}

/// æ”¿ç­–æ£€æŸ¥ç»“æœ
struct PolicyCheckResult: Codable, Identifiable {
    let id: UUID
    let overallCompliance: Bool
    let violations: [AirlinePolicyViolation]
    let warnings: [AirlinePolicyWarning]
    let recommendations: [String]
    let estimatedFees: AirlineEstimatedFees?
    
    enum CodingKeys: String, CodingKey {
        case id, overallCompliance, violations, warnings, recommendations, estimatedFees
    }
    
    init(overallCompliance: Bool, violations: [AirlinePolicyViolation], 
         warnings: [AirlinePolicyWarning], recommendations: [String], 
         estimatedFees: AirlineEstimatedFees? = nil) {
        self.id = UUID()
        self.overallCompliance = overallCompliance
        self.violations = violations
        self.warnings = warnings
        self.recommendations = recommendations
        self.estimatedFees = estimatedFees
    }
}

/// èˆªç©ºå…¬å¸æ”¿ç­–è¿è§„
struct AirlinePolicyViolation: Codable, Identifiable {
    let id: UUID
    let itemName: String
    let violationType: AirlineViolationType
    let description: String
    let severity: AirlineViolationSeverity
    let suggestion: String
    
    enum CodingKeys: String, CodingKey {
        case id, itemName, violationType, description, severity, suggestion
    }
    
    init(itemName: String, violationType: AirlineViolationType, description: String,
         severity: AirlineViolationSeverity, suggestion: String) {
        self.id = UUID()
        self.itemName = itemName
        self.violationType = violationType
        self.description = description
        self.severity = severity
        self.suggestion = suggestion
    }
}

/// èˆªç©ºå…¬å¸è¿è§„ç±»å‹
enum AirlineViolationType: String, Codable {
    case prohibited = "prohibited"
    case overweight = "overweight"
    case oversized = "oversized"
    case liquid = "liquid"
    case battery = "battery"
    case sharp = "sharp"
    
    var displayName: String {
        switch self {
        case .prohibited: return "ç¦æ­¢æºå¸¦"
        case .overweight: return "è¶…é‡"
        case .oversized: return "è¶…å°ºå¯¸"
        case .liquid: return "æ¶²ä½“é™åˆ¶"
        case .battery: return "ç”µæ± é™åˆ¶"
        case .sharp: return "å°–é”ç‰©å“"
        }
    }
}

/// èˆªç©ºå…¬å¸è¿è§„ä¸¥é‡ç¨‹åº¦
enum AirlineViolationSeverity: String, Codable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    case critical = "critical"
    
    var displayName: String {
        switch self {
        case .low: return "è½»å¾®"
        case .medium: return "ä¸­ç­‰"
        case .high: return "ä¸¥é‡"
        case .critical: return "æä¸¥é‡"
        }
    }
}

/// èˆªç©ºå…¬å¸æ”¿ç­–è­¦å‘Š
struct AirlinePolicyWarning: Codable, Identifiable {
    let id: UUID
    let itemName: String
    let warningType: WarningType
    let message: String
    let suggestion: String
    
    enum CodingKeys: String, CodingKey {
        case id, itemName, warningType, message, suggestion
    }
    
    init(itemName: String, warningType: WarningType, message: String, suggestion: String) {
        self.id = UUID()
        self.itemName = itemName
        self.warningType = warningType
        self.message = message
        self.suggestion = suggestion
    }
}

/// èˆªç©ºå…¬å¸é¢„ä¼°è´¹ç”¨
struct AirlineEstimatedFees: Codable {
    let overweightFee: Double
    let oversizeFee: Double
    let currency: String
    
    init(overweightFee: Double, oversizeFee: Double, currency: String = "CNY") {
        self.overweightFee = overweightFee
        self.oversizeFee = oversizeFee
        self.currency = currency
    }
    
    /// æ€»è´¹ç”¨
    var totalFee: Double {
        return overweightFee + oversizeFee
    }
    
    /// æ ¼å¼åŒ–æ˜¾ç¤º
    var formattedTotal: String {
        return String(format: "%.2f %@", totalFee, currency)
    }
}

// MARK: - æ™ºèƒ½å»ºè®®ç›¸å…³æ¨¡å‹

/// æ™ºèƒ½å»ºè®®
struct SmartSuggestion: Codable, Identifiable {
    let id: UUID
    let type: SuggestionType
    let title: String
    let description: String
    let priority: Int // 1-10
    let category: ItemCategory?
    let actionable: Bool // æ˜¯å¦å¯æ“ä½œ
    let metadata: [String: String] // é¢å¤–å…ƒæ•°æ®
    let createdAt: Date
    
    enum CodingKeys: String, CodingKey {
        case id, type, title, description, priority, category, actionable, metadata, createdAt
    }
    
    init(type: SuggestionType, title: String, description: String, priority: Int = 5, 
         category: ItemCategory? = nil, actionable: Bool = true, metadata: [String: String] = [:]) {
        self.id = UUID()
        self.type = type
        self.title = title
        self.description = description
        self.priority = priority
        self.category = category
        self.actionable = actionable
        self.metadata = metadata
        self.createdAt = Date()
    }
}

/// å»ºè®®ç±»å‹
enum SuggestionType: String, Codable {
    case itemRecommendation = "itemRecommendation"   // ç‰©å“æ¨è
    case packingOptimization = "packingOptimization" // è£…ç®±ä¼˜åŒ–
    case weightReduction = "weightReduction"         // å‡é‡å»ºè®®
    case spaceOptimization = "spaceOptimization"     // ç©ºé—´ä¼˜åŒ–
    case safetyWarning = "safetyWarning"            // å®‰å…¨è­¦å‘Š
    case travelTip = "travelTip"                    // æ—…è¡Œè´´å£«
    case weatherAlert = "weatherAlert"              // å¤©æ°”æé†’
    case culturalNote = "culturalNote"              // æ–‡åŒ–æé†’
    
    var displayName: String {
        switch self {
        case .itemRecommendation: return "ç‰©å“æ¨è"
        case .packingOptimization: return "è£…ç®±ä¼˜åŒ–"
        case .weightReduction: return "å‡é‡å»ºè®®"
        case .spaceOptimization: return "ç©ºé—´ä¼˜åŒ–"
        case .safetyWarning: return "å®‰å…¨è­¦å‘Š"
        case .travelTip: return "æ—…è¡Œè´´å£«"
        case .weatherAlert: return "å¤©æ°”æé†’"
        case .culturalNote: return "æ–‡åŒ–æé†’"
        }
    }
    
    var icon: String {
        switch self {
        case .itemRecommendation: return "ğŸ’¡"
        case .packingOptimization: return "ğŸ“¦"
        case .weightReduction: return "âš–ï¸"
        case .spaceOptimization: return "ğŸ“"
        case .safetyWarning: return "âš ï¸"
        case .travelTip: return "ğŸ’­"
        case .weatherAlert: return "ğŸŒ¤ï¸"
        case .culturalNote: return "ğŸŒ"
        }
    }
}

// MARK: - è¯·æ±‚æ¨¡å‹

/// æ—…è¡Œå»ºè®®è¯·æ±‚
struct TravelSuggestionRequest: Codable, Identifiable, Hashable {
    let id: UUID
    let destination: String
    let duration: Int
    let season: String
    let activities: [String]
    let travelStyle: String
    let budget: String
    let companions: Int
    
    enum CodingKeys: String, CodingKey {
        case id, destination, duration, season, activities, travelStyle, budget, companions
    }
    
    init(destination: String, duration: Int, season: String, activities: [String], 
         travelStyle: String = "standard", budget: String = "medium", companions: Int = 0) {
        self.id = UUID()
        self.destination = destination
        self.duration = duration
        self.season = season
        self.activities = activities
        self.travelStyle = travelStyle
        self.budget = budget
        self.companions = companions
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(destination)
        hasher.combine(duration)
        hasher.combine(season)
        hasher.combine(activities)
        hasher.combine(travelStyle)
        hasher.combine(budget)
        hasher.combine(companions)
    }
    
    static func == (lhs: TravelSuggestionRequest, rhs: TravelSuggestionRequest) -> Bool {
        return lhs.destination == rhs.destination &&
               lhs.duration == rhs.duration &&
               lhs.season == rhs.season &&
               lhs.activities == rhs.activities &&
               lhs.travelStyle == rhs.travelStyle &&
               lhs.budget == rhs.budget &&
               lhs.companions == rhs.companions
    }
}

/// è£…ç®±ä¼˜åŒ–è¯·æ±‚
struct PackingOptimizationRequest: Codable, Identifiable, Hashable {
    let id: UUID
    let luggageId: UUID
    let itemIds: [UUID]
    let constraints: PackingConstraints
    let preferences: PackingPreferences
    
    enum CodingKeys: String, CodingKey {
        case id, luggageId, itemIds, constraints, preferences
    }
    
    init(luggageId: UUID, itemIds: [UUID], constraints: PackingConstraints = .default, 
         preferences: PackingPreferences = .default) {
        self.id = UUID()
        self.luggageId = luggageId
        self.itemIds = itemIds
        self.constraints = constraints
        self.preferences = preferences
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(luggageId)
        hasher.combine(itemIds)
    }
    
    static func == (lhs: PackingOptimizationRequest, rhs: PackingOptimizationRequest) -> Bool {
        return lhs.luggageId == rhs.luggageId && lhs.itemIds == rhs.itemIds
    }
}

/// æ›¿ä»£å“è¯·æ±‚
struct AlternativesRequest: Codable, Identifiable, Hashable {
    let id: UUID
    let itemId: UUID
    let constraints: AlternativeConstraints
    let maxResults: Int
    
    enum CodingKeys: String, CodingKey {
        case id, itemId, constraints, maxResults
    }
    
    init(itemId: UUID, constraints: AlternativeConstraints = .default, maxResults: Int = 5) {
        self.id = UUID()
        self.itemId = itemId
        self.constraints = constraints
        self.maxResults = maxResults
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(itemId)
    }
    
    static func == (lhs: AlternativesRequest, rhs: AlternativesRequest) -> Bool {
        return lhs.itemId == rhs.itemId
    }
}

// MARK: - çº¦æŸå’Œåå¥½æ¨¡å‹

/// è£…ç®±çº¦æŸæ¡ä»¶
struct PackingConstraints: Codable {
    let maxWeight: Double
    let maxVolume: Double
    let restrictions: [String] // é™åˆ¶æ¡ä»¶
    let priorities: [ItemCategory] // ä¼˜å…ˆçº§ç±»åˆ«
    
    /// é»˜è®¤çº¦æŸæ¡ä»¶
    static let `default` = PackingConstraints(
        maxWeight: 23000, // 23kg
        maxVolume: 100000, // 100L
        restrictions: [],
        priorities: [.documents, .medicine, .electronics]
    )
}

/// è£…ç®±åå¥½
struct PackingPreferences: Codable {
    let prioritizeWeight: Bool
    let prioritizeVolume: Bool
    let prioritizeAccessibility: Bool
    let separateCategories: Bool
    
    static let `default` = PackingPreferences(
        prioritizeWeight: true,
        prioritizeVolume: true,
        prioritizeAccessibility: false,
        separateCategories: true
    )
}

/// æ›¿ä»£å“çº¦æŸæ¡ä»¶
struct AlternativeConstraints: Codable {
    let maxWeight: Double? // æœ€å¤§é‡é‡é™åˆ¶ï¼ˆå…‹ï¼‰
    let maxVolume: Double? // æœ€å¤§ä½“ç§¯é™åˆ¶ï¼ˆç«‹æ–¹å˜ç±³ï¼‰
    let maxBudget: Double? // é¢„ç®—ä¸Šé™ï¼ˆå…ƒï¼‰
    let requiredFeatures: [String]? // å¿…éœ€åŠŸèƒ½
    let excludedBrands: [String]? // æ’é™¤å“ç‰Œ
    let preferredBrands: [String]? // åå¥½å“ç‰Œ
    
    init(maxWeight: Double? = nil, maxVolume: Double? = nil, maxBudget: Double? = nil,
         requiredFeatures: [String]? = nil, excludedBrands: [String]? = nil,
         preferredBrands: [String]? = nil) {
        self.maxWeight = maxWeight
        self.maxVolume = maxVolume
        self.maxBudget = maxBudget
        self.requiredFeatures = requiredFeatures
        self.excludedBrands = excludedBrands
        self.preferredBrands = preferredBrands
    }
    
    /// é»˜è®¤çº¦æŸæ¡ä»¶
    static let `default` = AlternativeConstraints()
}

// MARK: - æ‰©å±•æ–¹æ³•

extension ItemInfo {
    /// åˆ›å»ºé»˜è®¤ç‰©å“ä¿¡æ¯
    static func defaultItem(name: String) -> ItemInfo {
        return ItemInfo(
            name: name,
            category: .other,
            weight: 100.0,
            volume: 100.0,
            confidence: 0.5,
            source: "é»˜è®¤å€¼"
        )
    }
    
    /// ä» AI å“åº”åˆ›å»º
    static func fromAIResponse(_ response: [String: Any], originalName: String) -> ItemInfo {
        let name = response["name"] as? String ?? originalName
        let categoryString = response["category"] as? String ?? "other"
        let category = ItemCategory(rawValue: categoryString) ?? .other
        let weight = response["weight"] as? Double ?? 100.0
        let volume = response["volume"] as? Double ?? 100.0
        let confidence = response["confidence"] as? Double ?? 0.8
        
        return ItemInfo(
            name: name,
            category: category,
            weight: weight,
            volume: volume,
            confidence: confidence,
            source: "AIè¯†åˆ«"
        )
    }
    
    /// Mock æ•°æ®
    static let mock = ItemInfo(
        name: "æµ‹è¯•ç‰©å“",
        category: .other,
        weight: 100.0,
        volume: 100.0,
        confidence: 0.8,
        source: "Mock"
    )
}

extension PhotoRecognitionResult {
    /// Mock æ•°æ®
    static let mock = PhotoRecognitionResult(
        itemInfo: ItemInfo.mock,
        confidence: 0.8,
        recognitionMethod: .cloudAPI,
        processingTime: 2.5,
        imageMetadata: ImageMetadata.mock
    )
}

extension ImageMetadata {
    /// Mock æ•°æ®
    static let mock = ImageMetadata(
        width: 1024,
        height: 768,
        fileSize: 1024000,
        format: "JPEG",
        dominantColors: ["#FF0000", "#00FF00", "#0000FF"],
        brightness: 0.7,
        contrast: 0.8,
        hasText: false,
        estimatedObjects: 1
    )
}

// MARK: - UIImage æ‰©å±•

extension UIImage {
    /// ä¿®æ­£å›¾ç‰‡æ–¹å‘
    func fixOrientation() -> UIImage {
        if imageOrientation == .up {
            return self
        }
        
        UIGraphicsBeginImageContextWithOptions(size, false, scale)
        draw(in: CGRect(origin: .zero, size: size))
        let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return normalizedImage ?? self
    }
}

// MARK: - ç¼ºå¤±çš„ç±»å‹å®šä¹‰

/// ç‰©å“è¯†åˆ«è¯·æ±‚
struct ItemIdentificationRequest: Codable, Hashable {
    let name: String
    let model: String?
    let category: ItemCategory?
    let hint: String?
    
    init(name: String, model: String? = nil, category: ItemCategory? = nil, hint: String? = nil) {
        self.name = name
        self.model = model
        self.category = category
        self.hint = hint
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
        hasher.combine(category)
        hasher.combine(hint)
    }
}

/// ç”¨æˆ·åå¥½
struct UserPreferences: Codable {
    let preferredBrands: [String]
    let avoidedItems: [String]
    let packingStyle: PackingStyle
    let budgetLevel: BudgetLevel
    let travelFrequency: TravelFrequency
    
    init() {
        self.preferredBrands = []
        self.avoidedItems = []
        self.packingStyle = .standard
        self.budgetLevel = .medium
        self.travelFrequency = .occasional
    }
}

/// è£…ç®±é£æ ¼
enum PackingStyle: String, Codable {
    case minimal = "minimal"     // è½»è£…
    case standard = "standard"   // æ ‡å‡†
    case comprehensive = "comprehensive" // å……åˆ†å‡†å¤‡
    
    var displayName: String {
        switch self {
        case .minimal: return "è½»è£…å‡ºè¡Œ"
        case .standard: return "æ ‡å‡†è£…å¤‡"
        case .comprehensive: return "å……åˆ†å‡†å¤‡"
        }
    }
}

/// é¢„ç®—æ°´å¹³
enum BudgetLevel: String, Codable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    
    var displayName: String {
        switch self {
        case .low: return "ç»æµå‹"
        case .medium: return "ä¸­ç­‰"
        case .high: return "é«˜ç«¯"
        }
    }
}

/// æ—…è¡Œé¢‘ç‡
enum TravelFrequency: String, Codable {
    case rare = "rare"           // å¾ˆå°‘
    case occasional = "occasional" // å¶å°”
    case frequent = "frequent"   // ç»å¸¸
    case business = "business"   // å•†åŠ¡
    
    var displayName: String {
        switch self {
        case .rare: return "å¾ˆå°‘æ—…è¡Œ"
        case .occasional: return "å¶å°”æ—…è¡Œ"
        case .frequent: return "ç»å¸¸æ—…è¡Œ"
        case .business: return "å•†åŠ¡å‡ºè¡Œ"
        }
    }
}

/// ç”¨æˆ·æ¡£æ¡ˆ
struct UserProfile: Codable {
    let id: UUID
    let preferences: UserPreferences
    let travelHistory: [TravelRecord]
    let itemPreferences: [ItemPreference]
    let createdAt: Date
    let updatedAt: Date
    
    init(id: UUID = UUID()) {
        self.id = id
        self.preferences = UserPreferences()
        self.travelHistory = []
        self.itemPreferences = []
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}

/// æ—…è¡Œè®°å½•
struct TravelRecord: Codable, Identifiable {
    let id: UUID
    let destination: String
    let startDate: Date
    let endDate: Date
    let purpose: TravelPurpose
    let satisfaction: Int // 1-5 æ»¡æ„åº¦
    let itemsUsed: [UUID] // ä½¿ç”¨çš„ç‰©å“ID
    let itemsUnused: [UUID] // æœªä½¿ç”¨çš„ç‰©å“ID
    let notes: String?
    
    init(destination: String, startDate: Date, endDate: Date, purpose: TravelPurpose) {
        self.id = UUID()
        self.destination = destination
        self.startDate = startDate
        self.endDate = endDate
        self.purpose = purpose
        self.satisfaction = 3
        self.itemsUsed = []
        self.itemsUnused = []
        self.notes = nil
    }
}

/// æ—…è¡Œç›®çš„
enum TravelPurpose: String, Codable {
    case leisure = "leisure"     // ä¼‘é—²
    case business = "business"   // å•†åŠ¡
    case family = "family"       // æ¢äº²
    case study = "study"         // å­¦ä¹ 
    case medical = "medical"     // åŒ»ç–—
    
    var displayName: String {
        switch self {
        case .leisure: return "ä¼‘é—²æ—…è¡Œ"
        case .business: return "å•†åŠ¡å‡ºè¡Œ"
        case .family: return "æ¢äº²è®¿å‹"
        case .study: return "å­¦ä¹ äº¤æµ"
        case .medical: return "åŒ»ç–—å¥åº·"
        }
    }
}

/// ç‰©å“åå¥½
struct ItemPreference: Codable, Identifiable {
    let id: UUID
    let itemName: String
    let category: ItemCategory
    let preference: PreferenceType
    let reason: String?
    
    init(itemName: String, category: ItemCategory, preference: PreferenceType, reason: String? = nil) {
        self.id = UUID()
        self.itemName = itemName
        self.category = category
        self.preference = preference
        self.reason = reason
    }
}

/// åå¥½ç±»å‹
enum PreferenceType: String, Codable {
    case love = "love"       // å–œæ¬¢
    case like = "like"       // ä¸€èˆ¬å–œæ¬¢
    case neutral = "neutral" // ä¸­æ€§
    case dislike = "dislike" // ä¸å–œæ¬¢
    case avoid = "avoid"     // é¿å…
    
    var displayName: String {
        switch self {
        case .love: return "éå¸¸å–œæ¬¢"
        case .like: return "å–œæ¬¢"
        case .neutral: return "ä¸­æ€§"
        case .dislike: return "ä¸å–œæ¬¢"
        case .avoid: return "é¿å…"
        }
    }
}

/// æ—…è¡Œè®¡åˆ’
struct TravelPlan: Codable, Identifiable {
    let id: UUID
    let destination: String
    let startDate: Date
    let endDate: Date
    let season: String
    let activities: [String]
    let airline: String?
    let weightLimit: Double?
    let companions: Int // åŒè¡Œäººæ•°
    let accommodation: AccommodationType
    let climate: ClimateInfo?
    
    init(destination: String, startDate: Date, endDate: Date, season: String, activities: [String]) {
        self.id = UUID()
        self.destination = destination
        self.startDate = startDate
        self.endDate = endDate
        self.season = season
        self.activities = activities
        self.airline = nil
        self.weightLimit = nil
        self.companions = 0
        self.accommodation = .hotel
        self.climate = nil
    }
    
    /// æ—…è¡Œå¤©æ•°
    var duration: Int {
        return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 1
    }
}

/// ä½å®¿ç±»å‹
enum AccommodationType: String, Codable {
    case hotel = "hotel"
    case hostel = "hostel"
    case airbnb = "airbnb"
    case camping = "camping"
    case family = "family"
    
    var displayName: String {
        switch self {
        case .hotel: return "é…’åº—"
        case .hostel: return "é’æ—…"
        case .airbnb: return "æ°‘å®¿"
        case .camping: return "éœ²è¥"
        case .family: return "äº²å‹å®¶"
        }
    }
}

/// æ°”å€™ä¿¡æ¯
struct ClimateInfo: Codable {
    let temperature: TemperatureRange
    let humidity: Double // æ¹¿åº¦ç™¾åˆ†æ¯”
    let rainfall: Double // é™é›¨é‡
    let season: String
    
    struct TemperatureRange: Codable {
        let min: Double
        let max: Double
        let unit: String // "C" or "F"
        
        var formatted: String {
            return "\(Int(min))Â°-\(Int(max))Â°\(unit)"
        }
    }
}

/// é—æ¼ç‰©å“è­¦å‘Š
struct MissingItemAlert: Codable, Identifiable {
    let id = UUID()
    let itemName: String
    let category: ItemCategory
    let importance: ImportanceLevel
    let reason: String
    let suggestion: String?
    
    enum CodingKeys: String, CodingKey {
        case itemName, category, importance, reason, suggestion
    }
}

/// é‡é‡é¢„æµ‹ç»“æœ
struct WeightPrediction: Codable {
    let totalWeight: Double
    let breakdown: [CategoryWeight]
    let warnings: [String]
    let suggestions: [String]
    let confidence: Double
    
    struct CategoryWeight: Codable {
        let category: ItemCategory
        let weight: Double
        let percentage: Double
    }
}

/// æ›¿ä»£ç‰©å“
struct AlternativeItem: Codable, Identifiable {
    let id: UUID
    let name: String
    let category: ItemCategory
    let weight: Double
    let volume: Double
    let dimensions: Dimensions
    let advantages: [String]
    let disadvantages: [String]
    let suitability: Double
    let reason: String
    let estimatedPrice: Double?
    let availability: String?
    let compatibilityScore: Double
    let functionalityMatch: Double?
    let versatility: Double?
    
    enum CodingKeys: String, CodingKey {
        case id, name, category, weight, volume, dimensions, advantages, disadvantages, 
             suitability, reason, estimatedPrice, availability, compatibilityScore,
             functionalityMatch, versatility
    }
    
    init(name: String, category: ItemCategory, weight: Double, volume: Double,
         dimensions: Dimensions, advantages: [String], disadvantages: [String],
         suitability: Double, reason: String, estimatedPrice: Double? = nil,
         availability: String? = nil, compatibilityScore: Double,
         functionalityMatch: Double? = nil, versatility: Double? = nil) {
        self.id = UUID()
        self.name = name
        self.category = category
        self.weight = weight
        self.volume = volume
        self.dimensions = dimensions
        self.advantages = advantages
        self.disadvantages = disadvantages
        self.suitability = suitability
        self.reason = reason
        self.estimatedPrice = estimatedPrice
        self.availability = availability
        self.compatibilityScore = compatibilityScore
        self.functionalityMatch = functionalityMatch
        self.versatility = versatility
    }
}

/// èˆªç­ç±»å‹
enum FlightType: String, Codable {
    case domestic = "domestic"
    case international = "international"
    
    var displayName: String {
        switch self {
        case .domestic: return "å›½å†…èˆªç­"
        case .international: return "å›½é™…èˆªç­"
        }
    }
}

/// èˆ±ä½ç­‰çº§
enum CabinClass: String, Codable {
    case economy = "economy"
    case business = "business"
    case first = "first"
    
    var displayName: String {
        switch self {
        case .economy: return "ç»æµèˆ±"
        case .business: return "å•†åŠ¡èˆ±"
        case .first: return "å¤´ç­‰èˆ±"
        }
    }
}

// MARK: - åè®®å®šä¹‰

/// è¡Œæé¡¹ç›®åè®®
protocol LuggageItemProtocol {
    var id: UUID { get }
    var name: String { get }
    var weight: Double { get }
    var volume: Double { get }
}

/// è¡Œæç®±åè®®
protocol LuggageProtocol {
    var id: UUID { get }
    var name: String { get }
    var capacity: Double { get }
    var emptyWeight: Double { get }
}

// MARK: - ç±»å‹åˆ«åï¼ˆä¸ºäº†å…¼å®¹æ€§ï¼‰

/// æ”¿ç­–è¿è§„ç±»å‹åˆ«å
typealias PolicyViolation = AirlinePolicyViolation

/// æ”¿ç­–è­¦å‘Šç±»å‹åˆ«å
typealias PolicyWarning = AirlinePolicyWarning

/// é¢„ä¼°è´¹ç”¨ç±»å‹åˆ«å
typealias EstimatedFees = AirlineEstimatedFees

/// è¿è§„ç±»å‹åˆ«å
typealias ViolationType = AirlineViolationType

/// è¿è§„ä¸¥é‡ç¨‹åº¦åˆ«å
typealias ViolationSeverity = AirlineViolationSeverity

// MARK: - æ‰¹é‡è¯†åˆ«ç»“æœ

// BatchRecognitionResult å·²åœ¨ BatchRecognitionService.swift ä¸­å®šä¹‰

// DetectedObject å·²åœ¨ ObjectDetectionEngine.swift ä¸­å®šä¹‰

/// å¯¹è±¡ç±»åˆ«
enum ObjectCategory: String, Codable, CaseIterable {
    case clothing = "clothing"
    case electronics = "electronics"
    case accessories = "accessories"
    case toiletries = "toiletries"
    case documents = "documents"
    case food = "food"
    case other = "other"
    
    var displayName: String {
        switch self {
        case .clothing: return "è¡£ç‰©"
        case .electronics: return "ç”µå­äº§å“"
        case .accessories: return "é…é¥°"
        case .toiletries: return "æ´—æ¼±ç”¨å“"
        case .documents: return "æ–‡ä»¶"
        case .food: return "é£Ÿå“"
        case .other: return "å…¶ä»–"
        }
    }
}